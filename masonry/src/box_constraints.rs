// Copyright 2019 the Xilem Authors and the Druid Authors
// SPDX-License-Identifier: Apache-2.0

use vello::kurbo::Size;

/// Constraints for layout.
///
/// The layout strategy for Masonry is strongly inspired by Flutter,
/// and this struct is similar to the [Flutter BoxConstraints] class.
///
/// At the moment, it represents simply a minimum and maximum size.
/// A widget's [`layout`] method should choose an appropriate size that
/// meets these constraints.
///
/// Further, a container widget should compute appropriate constraints
/// for each of its child widgets, and pass those down when recursing.
///
/// The constraints are always [rounded away from zero] to integers
/// to enable pixel perfect layout.
///
/// [`layout`]: crate::widget::Widget::layout
/// [Flutter BoxConstraints]: https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html
/// [rounded away from zero]: Size::expand
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BoxConstraints {
    max: Size,
}

impl BoxConstraints {
    /// An unbounded box constraints object.
    ///
    /// Can be satisfied by any nonnegative size.
    pub const UNBOUNDED: BoxConstraints = BoxConstraints {
        max: Size::new(f64::INFINITY, f64::INFINITY),
    };

    /// Create a new box constraints object.
    ///
    /// Create constraints based on minimum and maximum size.
    ///
    /// The given sizes are also [rounded away from zero],
    /// so that the layout is aligned to integers.
    ///
    /// [rounded away from zero]: Size::expand
    pub fn new(max: Size) -> BoxConstraints {
        BoxConstraints {
            max: max.expand(),
        }
    }

    /// Clamp a given size so that it fits within the constraints.
    ///
    /// The given size is also [rounded away from zero],
    /// so that the layout is aligned to integers.
    ///
    /// [rounded away from zero]: Size::expand
    pub fn constrain(&self, size: impl Into<Size>) -> Size {
        size.into().expand().clamp(Size::ZERO, self.max)
    }

    /// Returns the max size of these constraints.
    pub fn max(&self) -> Size {
        self.max
    }

    /// Whether there is an upper bound on the width.
    pub fn is_width_bounded(&self) -> bool {
        self.max.width.is_finite()
    }

    /// Whether there is an upper bound on the height.
    pub fn is_height_bounded(&self) -> bool {
        self.max.height.is_finite()
    }

    /// Check to see if these constraints are legit.
    ///
    /// In Debug mode, logs a warning if `BoxConstraints` are invalid.
    pub fn debug_check(&self, name: &str) {
        if cfg!(not(debug_assertions)) {
            return;
        }

        if !(0.0 <= self.max.width && 0.0 <= self.max.height && self.max.expand() == self.max) {
            tracing::warn!("Bad BoxConstraints passed to {}:", name);
            tracing::warn!("{:?}", self);
        }

        if self.max.width.is_nan() {
            debug_panic!("Maximum width constraint passed to {name} is NaN");
        }
        if self.max.height.is_nan() {
            debug_panic!("Maximum height constraint passed to {name} is NaN");
        }
    }

    /// Shrink min and max constraints by size
    ///
    /// The given size is also [rounded away from zero],
    /// so that the layout is aligned to integers.
    ///
    /// [rounded away from zero]: Size::expand
    pub fn shrink(&self, diff: impl Into<Size>) -> BoxConstraints {
        let diff = diff.into().expand();
        let max = Size::new(
            (self.max().width - diff.width).max(0.),
            (self.max().height - diff.height).max(0.),
        );

        BoxConstraints::new(max)
    }

    /// Test whether these constraints contain the given `Size`.
    pub fn contains(&self, size: impl Into<Size>) -> bool {
        let size = size.into();
        (size.width <= self.max.width) && (size.height <= self.max.height)
    }

    /// Find the `Size` within these `BoxConstraint`s that minimises the difference between the
    /// returned `Size`'s aspect ratio and `aspect_ratio`, where *aspect ratio* is defined as
    /// `height / width`.
    ///
    /// If multiple `Size`s give the optimal `aspect_ratio`, then the one with the `width` nearest
    /// the supplied width will be used. Specifically, if `width == 0.0` then the smallest possible
    /// `Size` will be chosen, and likewise if `width == f64::INFINITY`, then the largest `Size`
    /// will be chosen.
    ///
    /// Use this function when maintaining an aspect ratio is more important than minimizing the
    /// distance between input and output size width and height.
    pub fn constrain_aspect_ratio(&self, aspect_ratio: f64, width: f64) -> Size {
        // Minimizing/maximizing based on aspect ratio seems complicated, but in reality everything
        // is linear, so the amount of work to do is low.
        let ideal_size = Size {
            width,
            height: width * aspect_ratio,
        };

        // It may be possible to remove these in the future if the invariant is checked elsewhere.
        let aspect_ratio = aspect_ratio.abs();
        let width = width.abs();

        // Firstly check if we can simply return the exact requested
        if self.contains(ideal_size) {
            return ideal_size;
        }

        // Then we check if any `Size`s with our desired aspect ratio are inside the constraints.
        // TODO this currently outputs garbage when things are < 0 - See https://github.com/linebender/xilem/issues/377
        let min_w_min_h = 0.0 / 0.0;
        let max_w_min_h = 0.0 / self.max.width;
        let min_w_max_h = self.max.height / 0.0;
        let max_w_max_h = self.max.height / self.max.width;

        // When the aspect ratio line crosses the constraints, the closest point must be one of the
        // two points where the aspect ratio enters/exits.

        // When the aspect ratio line doesn't intersect the box of possible sizes, the closest
        // point must be either (max width, min height) or (max height, min width). So all we have
        // to do is check which one of these has the closest aspect ratio.

        // Check each possible intersection (or not) of the aspect ratio line with the constraints
        if aspect_ratio > min_w_max_h {
            // outside max height min width
            Size {
                width: 0.0,
                height: self.max.height,
            }
        } else if aspect_ratio < max_w_min_h {
            // outside min height max width
            Size {
                width: self.max.width,
                height: 0.0,
            }
        } else if aspect_ratio > min_w_min_h {
            // hits the constraints on the min width line
            if width < 0.0 {
                // we take the point on the min width
                Size {
                    width: 0.0,
                    height: 0.0 * aspect_ratio,
                }
            } else if aspect_ratio < max_w_max_h {
                // exits through max.width
                Size {
                    width: self.max.width,
                    height: self.max.width * aspect_ratio,
                }
            } else {
                // exits through max.height
                Size {
                    width: self.max.height * aspect_ratio.recip(),
                    height: self.max.height,
                }
            }
        } else {
            // final case is where we hit constraints on the min height line
            if width < 0.0 {
                // take the point on the min height
                Size {
                    width: 0.0 * aspect_ratio.recip(),
                    height: 0.0,
                }
            } else if aspect_ratio > max_w_max_h {
                // exit thru max height
                Size {
                    width: self.max.height * aspect_ratio.recip(),
                    height: self.max.height,
                }
            } else {
                // exit thru max width
                Size {
                    width: self.max.width,
                    height: self.max.width * aspect_ratio,
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn bc(max_width: f64, max_height: f64) -> BoxConstraints {
        BoxConstraints::new(Size::new(max_width, max_height))
    }

    #[test]
    fn unbounded() {
        assert!(!BoxConstraints::UNBOUNDED.is_width_bounded());
        assert!(!BoxConstraints::UNBOUNDED.is_height_bounded());
    }
}